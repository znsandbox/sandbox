Контракты
===
## Основные положения

### Хороший стиль

* **Идентификаторы и имена**. Осмысленные и в едином стиле.

### Плохой стиль

* **CamelCase**. Неудобочитаем.
* **Префиксы и венгерская нотация**. Префиксы наподобие `sp_` или `tbl_` избыточны.
* **Множественное число**. Лучше использовать более естественно звучащие собирательные понятия. Например:
	* `staff` вместо `employees`
	* `people` вместо `individuals`.

## Соглашения о наименовании

### Общее

* Названия всегда давайте в **единственном числе**.
* Названия всегда пишите **строчными буквами**.
* **Используйте** в именах только буквы, цифры и символ подчёркивания.
* **Используйте** [snack_case](https://ru.wikipedia.org/wiki/Snake_case) стиль именования.
* **Убедитесь** в том, что имя уникально и его нет в списке зарезервированных ключевых слов.
* **Ограничивайте** длину имени 30 байтами (это 30 символов, если не используется многобайтный набор символов).
* **Начинайте** имена с буквы и **не заканчивайте** их символом подчёркивания.
* **Избегайте** сокращений. Если их всё же нужно использовать, убедитесь в том, что они общепонятны.
* **Избегайте** нескольких подряд идущих символов подчёркивания.

### Таблицы

* **Не используйте** описательные префиксы вида `tbl_` и венгерскую нотацию в целом.
* **Не допускайте** совпадений названия таблицы с названием любого из её столбцов.
* **Промежуточным** таблицам даем имена с префиксом `tie_` (например: `tie_role_account`)
  * Если БД не разбита на схемы, то сначала ставим префикс **предметной** области, затем префикс `tie` (например: `user_tie_role_account`)

#### Универсальные суффиксы для таблиц

* `_localization` — таблица, содержащая переводы значений сущности на разные языки.
* `_log` — таблица для логирования.

### Столбцы

* По возможности, **используйте** `id` в качестве первичного идентификатора таблицы.
* **Не создавайте** в таблице столбцов с таким же названием, как у неё самой.
* поля, означающие **время**, именуются с суффиксом `_at` (например: `created_at`, `updated_at`, `publicated_at`)
* **флаги** именуются с префиксом `is_` (например: `is_readed`, `is_favorite`)
* **флаги наличия** именуются с префиксом `has_` (например: `has_files`, `has_comment`)
* **порядок сортровки** именуется как `sort`
* **не используйте** `not` в названии флага, лучше назвать поле `is_new` вместо `is_not_readed`.
* поля, используемые для **связи** с другими таблицами, именуются с суффиксом (например: `user_id`, `company_id`, `currency_code`)
	* имя поля со связью составляется так: `таблица_поле`, где таблица и поле те, на которые ссылаемся
	* но есть и исключения, например, "редактор новости" может именоваться как `editor_id`, а ссылаться на таблицу `person`. Причина этому - в предметной области "новости" фигурирует понятие "редактор".
	* если поле ссылется на поле этой же таблицы, то именуем так: `parent_id`, `parent_name`.
* имена поля для **названия** сущности именуем как `name`.

#### Универсальные суффиксы для столбцов

Приведённые ниже суффиксы универсальны, что гарантирует простоту понимания значения столбцов из кода SQL.

* `_id` — связь с другой таблицей через ее первичный ключ.
* `_status` — флаг или любой статус, например `publication_status`.
* `_total` или `_count` — общее количество или сумма значений.
* `_num` — поле, содержащее число.
* `_name` — любое имя, например `first_name`.
* `_seq` — непрерывная последовательность значений.
* `_at` — колонка, содержащая дату.
* `_tally` — счётчик.
* `_size` — размер или величина чего-либо, например размер файла.
* `_addr` — физический или абстрактный адрес, например `ip_addr`.

#### Типы данных

* По возможности **не используйте** специфичные для той или иной СУБД типы данных. Это может негативно сказаться на переносимости, а также этих типов может не оказаться в старых версиях этих же СУБД.
* Для работы с плавающей точкой **используйте** только `REAL` или `FLOAT`, но где нет необходимости в подобных вычислениях, всегда **используйте** `NUMERIC` и `DECIMAL`. Ошибки округления в операциях с плавающей точкой могут оказаться очень некстати.

### Расположение и порядок

* Первичный ключ
* Уникальные атрибуты
* Различные значения
* Статусы
* Флаги
* Сортировка
* Время

### Хранимые процедуры

* Имя должно содержать глагол.
* Не используйте описательные префиксы вида `sp_` и венгерскую нотацию в целом.

## Ограничения и ключи

Ограничения и их подмножество, ключи, — важная часть любой структуры базы данных, поэтому важно следовать стандартам их объявления, чтобы избежать трудностей в последующей поддержке написанного.

### Ключи

Выбор столбцов, которые будут играть роль ключей, должен быть обоснован и предельно выверен, поскольку от них напрямую зависит производительность и целостность данных.

* Ключ должен быть в какой-то степени уникальным.
* Должна быть согласованность по типу данных для значения во всей схеме, а также чем ниже вероятность того, что это изменится в будущем, тем лучше.
* Можно ли проверить значение на соответствие стандарту (например, ISO)?
* Ключ должен быть как можно проще, чтобы можно было без трудностей использовать составные ключи.

Это своего рода конвенции, которые нужно сформулировать при проектировании базы данных. Если требования впоследствии будут разрастаться, можно и нужно вносить изменения в структуру базы, чтобы поддерживать её в актуальном состоянии.

### Ограничения

Как только решено, какие ключи должны использоваться, нужно определить их в базе с помощью ограничений наряду с валидацией значений полей.

### Общее

* У каждой таблицы **должен быть** хотя бы один ключ.
* Ограничениям нужно **присваивать** вразумительные имена. Для UNIQUE, PRIMARY KEY и FOREIGN KEY подобные имена создаются автоматически, поэтому нужно позаботиться об остальных ограничениях.

## Структура БД

Есть два варианта структуры БД:

* **плоская** БД, где все таблицы находятся в одной схеме
* БД, **разбитая на схемы**

### Плоская БД

Для плоской БД, таблицы именуем, начиная с префикса предметной области.

Пример именования таблиц из предметных областей (пользователь, файловое хранилище, справочники):

* user_account
* user_role_assignment
* user_person
* storage_file
* storage_image
* storage_service
* storage_service_thumb
* reference_item
* reference_book
* reference_item_translation
* reference_book_localization

### БД со схемами

Для варианта с разбитием на схемы, каждую предметную область помещаем в отдельную схему.

Например:

* таблицы предметной области "пользователь", храним в схеме "user"
* таблицы предметной области "файловое хранилище", храним в схеме "storage"
* таблицы предметной области "справочники", храним в схеме "reference"

Вот что примерно должно получиться:

* user
	* account
	* role_assignment
	* person
* storage
	* file
	* image
	* service
	* service_thumb
* reference
	* item
	* book
	* item_localization
	* book_localization

> Note: Если БД позволяет использовать схемы, то разбивка по схемам более предпочтительна.
